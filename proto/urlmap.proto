syntax = "proto3";
import "google/protobuf/empty.proto";
package urlmap;

service Redirection {
  rpc GetOrgByPath (RedirectPath) returns (OrgUrl);
  rpc GetInfoByUser (User) returns (ArrayRedirectData);
  rpc SetInfo (RedirectData) returns (OrgUrl);
  rpc SetUser (User) returns (User);
  rpc RemoveUser (User) returns (google.protobuf.Empty);
  rpc ListUsers (google.protobuf.Empty) returns (Users);
}

message RedirectPath {
  string path = 1;
  string notify_to = 2;
}

message OrgUrl {
  string org = 1;
  string notify_to = 2;
  string slack_url = 3;
  string email = 4;
}

message User {
  string user = 1;
  string notify_to = 2;
  string slack_url = 3;
  string email = 4;
}

message ArrayRedirectData {
  repeated RedirectData redirects = 1;
}

message RedirectData {
    RedirectInfo redirect = 1;
    message ValidDate {
        string begin = 1;
        string end  = 2;
    }
}

message RedirectInfo {
    string user = 1;
    string redirectPath = 2;
    string org = 3;
    string host = 4;
    string comment = 5;
    int32 active = 6;

}

message Users {
  repeated User users = 1;
}


// option go_package = "google.golang.org/grpc/health/grpc_health_v1";
message HealthCheckRequest {
  string service = 1;
}

message HealthCheckResponse {
  enum ServingStatus {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
    SERVICE_UNKNOWN = 3;  // Used only by the Watch method.
  }
  ServingStatus status = 1;
}

service Health {
  // If the requested service is unknown, the call will fail with status
  // NOT_FOUND.
  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);

  // Performs a watch for the serving status of the requested service.
  // The server will immediately send back a message indicating the current
  // serving status.  It will then subsequently send a new message whenever
  // the service's serving status changes.
  //
  // If the requested service is unknown when the call is received, the
  // server will send a message setting the serving status to
  // SERVICE_UNKNOWN but will *not* terminate the call.  If at some
  // future point, the serving status of the service becomes known, the
  // server will send a new message with the service's serving status.
  //
  // If the call terminates with status UNIMPLEMENTED, then clients
  // should assume this method is not supported and should not retry the
  // call.  If the call terminates with any other status (including OK),
  // clients should retry the call with appropriate exponential backoff.
  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);
}